# Func (no params)

func NoParams() -> int {
  return int(42);
}

==>

Program(Func(Ident,Semiring,Block(LBrace,Return(LiteralExpr(Semiring,Number)),RBrace)))

# Func (one param)

func OneParam(i:int) -> int {
  return int(42);
}

==>

Program(Func(Ident,Param(Ident,Semiring),Semiring,Block(LBrace,Return(LiteralExpr(Semiring,Number)),RBrace)))

# Func (two params param)

func OneParam(i:int, j:int) -> int {
  return int(42);
}

==>

Program(Func(Ident,Param(Ident,Semiring),Param(Ident,Semiring),Semiring,Block(LBrace,Return(LiteralExpr(Semiring,Number)),RBrace)))

# Type (Matrix)

func Mat(a: Matrix<s, 1, int>) -> int {
  return int(42);
}

==>

Program(Func(Ident,Param(Ident,MatrixType(Matrix,Dim(Ident),Dim(DimOne),Semiring)),Semiring,Block(LBrace,Return(LiteralExpr(Semiring,Number)),RBrace)))

# Type (Vector)

func Vec(a: Vector<s, int>) -> int {
  return int(42);
}

==>

Program(Func(Ident,Param(Ident,VectorType(Vector,Dim(Ident),Semiring)),Semiring,Block(LBrace,Return(LiteralExpr(Semiring,Number)),RBrace)))

# Assign (plain)

func Assign(a: int) -> int {
  b = a;
  return b;
}

==>

Program(Func(Ident,Param(Ident,Semiring),Semiring,Block(LBrace,Assign(Ident,Ident),Return(Ident),RBrace)))

# Assign (mask)

func Assign(a: Vector<s, int>, m: Vector<s, int>, b: Vector<s, int>) -> Vector<s, int> {
  a<m> = b;
  return a;
}

==>

Program(Func(Ident,Param(Ident,VectorType(Vector,Dim(Ident),Semiring)),Param(Ident,VectorType(Vector,Dim(Ident),Semiring)),Param(Ident,VectorType(Vector,Dim(Ident),Semiring)),VectorType(Vector,Dim(Ident),Semiring),Block(LBrace,Assign(Ident,Mask(Ident),Ident),Return(Ident),RBrace)))

# Assign (mask with negation) 
func maskNeg(a: Vector<s, int>, m: Vector<s, int>, b: Vector<s, int>) -> Vector<s, int> {
  a<!m> = b;
  return a;
}

==>

Program(Func(Ident,Param(Ident,VectorType(Vector,Dim(Ident),Semiring)),Param(Ident,VectorType(Vector,Dim(Ident),Semiring)),Param(Ident,VectorType(Vector,Dim(Ident),Semiring)),VectorType(Vector,Dim(Ident),Semiring),Block(LBrace,Assign(Ident,Mask(Not,Ident),Ident),Return(Ident),RBrace)))

# Assign (fill)

func Assign(a: Vector<s, int>) -> Vector<s, int> {
  a[:] = int(42);
  return a;
}

==>

Program(Func(Ident,Param(Ident,VectorType(Vector,Dim(Ident),Semiring)),VectorType(Vector,Dim(Ident),Semiring),Block(LBrace,Assign(Ident,Fill,LiteralExpr(Semiring,Number)),Return(Ident),RBrace)))

# Accumulate
func accumulate(a: Vector<s, int>, b: Vector<s, int>) -> Vector<s, int> {
  a += b;
  return a;
}

==>

Program(Func(Ident,Param(Ident,VectorType(Vector,Dim(Ident),Semiring)),Param(Ident,VectorType(Vector,Dim(Ident),Semiring)),VectorType(Vector,Dim(Ident),Semiring),Block(LBrace,Accum(Ident,Ident),Return(Ident),RBrace)))

# For (const)
func ForConst() -> int {
  for i in int(0):int(10) {
  }
  return int(42);
}

==>

Program(Func(Ident,Semiring,Block(LBrace,For(Ident,RangeConst(LiteralExpr(Semiring,Number),LiteralExpr(Semiring,Number)),Block(LBrace,RBrace)),Return(LiteralExpr(Semiring,Number)),RBrace)))

# For (dim)
func ForDim(a: Matrix<s, s, int>) -> Matrix<s, s, int> {
  for i in a.nrows {
  }
  return a;
}

==>

Program(Func(Ident,Param(Ident,MatrixType(Matrix,Dim(Ident),Dim(Ident),Semiring)),MatrixType(Matrix,Dim(Ident),Dim(Ident),Semiring),Block(LBrace,For(Ident,RangeDim(PropExpr(Ident,Dot,Property)),Block(LBrace,RBrace)),Return(Ident),RBrace)))

# For with until
func forUntil(a: Matrix<s, s, int>) -> Matrix<s, s, int> {
  for i in a.nrows {
  } until bool(false);
  return a;
}

==>

Program(Func(Ident,Param(Ident,MatrixType(Matrix,Dim(Ident),Dim(Ident),Semiring)),MatrixType(Matrix,Dim(Ident),Dim(Ident),Semiring),Block(LBrace,For(Ident,RangeDim(PropExpr(Ident,Dot,Property)),Block(LBrace,RBrace),Until(LiteralExpr(Semiring,Boolean))),Return(Ident),RBrace)))

# Transpose
func Trans(a: Matrix<s, s, int>) -> Matrix<s, s, int> {
  return a.T;
}

==>

Program(Func(Ident,Param(Ident,MatrixType(Matrix,Dim(Ident),Dim(Ident),Semiring)),MatrixType(Matrix,Dim(Ident),Dim(Ident),Semiring),Block(LBrace,Return(PropExpr(Ident,Dot,Property)),RBrace)))

# nrows
func nrows(a: Matrix<s, s, int>) -> int {
  return a.nrows;
}

==>

Program(Func(Ident,Param(Ident,MatrixType(Matrix,Dim(Ident),Dim(Ident),Semiring)),Semiring,Block(LBrace,Return(PropExpr(Ident,Dot,Property)),RBrace)))

# ncols
func ncols(a: Matrix<s, s, int>) -> int {
  return a.ncols;
}

==>

Program(Func(Ident,Param(Ident,MatrixType(Matrix,Dim(Ident),Dim(Ident),Semiring)),Semiring,Block(LBrace,Return(PropExpr(Ident,Dot,Property)),RBrace)))

# nvals
func nvals(a: Matrix<s, s, int>) -> int {
  return a.nvals;
}

==>

Program(Func(Ident,Param(Ident,MatrixType(Matrix,Dim(Ident),Dim(Ident),Semiring)),Semiring,Block(LBrace,Return(PropExpr(Ident,Dot,Property)),RBrace)))

# arith (+ *)
func arith(a:int, b:int, c:int) -> int {
  return a + b * c;
}

==>

Program(Func(Ident,Param(Ident,Semiring),Param(Ident,Semiring),Param(Ident,Semiring),Semiring,Block(LBrace,Return(AddExpr(Ident,Plus,MulExpr(Ident,Times,Ident))),RBrace)))

# arith (- /)
func arith(a:int, b:int, c:int) -> int {
  return a - b / c;
}

==>

Program(Func(Ident,Param(Ident,Semiring),Param(Ident,Semiring),Param(Ident,Semiring),Semiring,Block(LBrace,Return(SubExpr(Ident,Minus,DivExpr(Ident,Div,Ident))),RBrace)))

# compare (==)
func compare(a:int, b:int) -> bool {
  return a == b;
}

==>

Program(Func(Ident,Param(Ident,Semiring),Param(Ident,Semiring),Semiring,Block(LBrace,Return(CompareExpr(Ident,Comparator,Ident)),RBrace)))

# compare (!=)
func compare(a:int, b:int) -> bool {
  return a != b;
}

==>

Program(Func(Ident,Param(Ident,Semiring),Param(Ident,Semiring),Semiring,Block(LBrace,Return(CompareExpr(Ident,Comparator,Ident)),RBrace)))

# compare (<)
func compare(a:int, b:int) -> bool {
  return a < b;
}

==>

Program(Func(Ident,Param(Ident,Semiring),Param(Ident,Semiring),Semiring,Block(LBrace,Return(CompareExpr(Ident,Comparator,Ident)),RBrace)))

# compare (>)
func compare(a:int, b:int) -> bool {
  return a > b;
}

==>

Program(Func(Ident,Param(Ident,Semiring),Param(Ident,Semiring),Semiring,Block(LBrace,Return(CompareExpr(Ident,Comparator,Ident)),RBrace)))

# compare (<=)
func compare(a:int, b:int) -> bool {
  return a <= b;
}

==>

Program(Func(Ident,Param(Ident,Semiring),Param(Ident,Semiring),Semiring,Block(LBrace,Return(CompareExpr(Ident,Comparator,Ident)),RBrace)))

# compare (>=)
func compare(a:int, b:int) -> bool {
  return a >= b;
}

==>

Program(Func(Ident,Param(Ident,Semiring),Param(Ident,Semiring),Semiring,Block(LBrace,Return(CompareExpr(Ident,Comparator,Ident)),RBrace)))

# Not
func not(a:bool) -> bool {
  return !a;
}

==>

Program(Func(Ident,Param(Ident,Semiring),Semiring,Block(LBrace,Return(NotExpr(Not,Ident)),RBrace)))

# Negation
func neg(a:int) -> int {
  return -a;
}

==>

Program(Func(Ident,Param(Ident,Semiring),Semiring,Block(LBrace,Return(NegExpr(Minus,Ident)),RBrace)))

# Matrix constructor
func matrix(m: Matrix<r, c, int>) -> Matrix<r, c, int> {
  return Matrix<int>(m.nrows, m.ncols);
}

==>

Program(Func(Ident,Param(Ident,MatrixType(Matrix,Dim(Ident),Dim(Ident),Semiring)),MatrixType(Matrix,Dim(Ident),Dim(Ident),Semiring),Block(LBrace,Return(MatrixExpr(Matrix,Semiring,PropExpr(Ident,Dot,Property),PropExpr(Ident,Dot,Property))),RBrace)))

# Vector constructor
func vector(v: Vector<s, int>) -> Vector<s, int> {
  return Vector<int>(v.nrows);
}

==>

Program(Func(Ident,Param(Ident,VectorType(Vector,Dim(Ident),Semiring)),VectorType(Vector,Dim(Ident),Semiring),Block(LBrace,Return(VectorExpr(Vector,Semiring,PropExpr(Ident,Dot,Property))),RBrace)))

# Diagonal
func diagonal(a: Vector<s, int>) -> Matrix<s, s, int> {
  return diag(a);
}

==>

Program(Func(Ident,Param(Ident,VectorType(Vector,Dim(Ident),Semiring)),MatrixType(Matrix,Dim(Ident),Dim(Ident),Semiring),Block(LBrace,Return(CallExpr(BuiltInFunc,Ident)),RBrace)))

# Apply
func applyOp(a: Matrix<s, s, int>) -> Matrix<s, s, int> {
  return apply(add, a);
}

==>

Program(Func(Ident,Param(Ident,MatrixType(Matrix,Dim(Ident),Dim(Ident),Semiring)),MatrixType(Matrix,Dim(Ident),Dim(Ident),Semiring),Block(LBrace,Return(CallExpr(BuiltInFunc,Ident,Ident)),RBrace)))

# Apply (extra arg)
func applyOpAcc(a: Matrix<s, s, int>, b: int) -> Matrix<s, s, int> {
  return apply(add, a, b);
}

==>

Program(Func(Ident,Param(Ident,MatrixType(Matrix,Dim(Ident),Dim(Ident),Semiring)),Param(Ident,Semiring),MatrixType(Matrix,Dim(Ident),Dim(Ident),Semiring),Block(LBrace,Return(CallExpr(BuiltInFunc,Ident,Ident,Ident)),RBrace)))

# Select
func selectOp(a: Matrix<s, s, int>) -> Matrix<s, s, int> {
  return select(pred, a);
}

==>

Program(Func(Ident,Param(Ident,MatrixType(Matrix,Dim(Ident),Dim(Ident),Semiring)),MatrixType(Matrix,Dim(Ident),Dim(Ident),Semiring),Block(LBrace,Return(CallExpr(BuiltInFunc,Ident,Ident)),RBrace)))

# Select (extra arg)
func selectOpThresh(a: Matrix<s, s, int>, t: int) -> Matrix<s, s, int> {
  return select(pred, a, t);
}

==>

Program(Func(Ident,Param(Ident,MatrixType(Matrix,Dim(Ident),Dim(Ident),Semiring)),Param(Ident,Semiring),MatrixType(Matrix,Dim(Ident),Dim(Ident),Semiring),Block(LBrace,Return(CallExpr(BuiltInFunc,Ident,Ident,Ident)),RBrace)))

# Lower triangular
func lowerTri(a: Matrix<s, s, int>) -> Matrix<s, s, int> {
  return tril(a);
}

==>

Program(Func(Ident,Param(Ident,MatrixType(Matrix,Dim(Ident),Dim(Ident),Semiring)),MatrixType(Matrix,Dim(Ident),Dim(Ident),Semiring),Block(LBrace,Return(CallExpr(BuiltInFunc,Ident)),RBrace)))

# Upper triangular
func upperTri(a: Matrix<s, s, int>) -> Matrix<s, s, int> {
  return triu(a);
}

==>

Program(Func(Ident,Param(Ident,MatrixType(Matrix,Dim(Ident),Dim(Ident),Semiring)),MatrixType(Matrix,Dim(Ident),Dim(Ident),Semiring),Block(LBrace,Return(CallExpr(BuiltInFunc,Ident)),RBrace)))

# Reduce rows
func reduceR(a: Matrix<s, s, int>) -> Vector<s, int> {
  return reduceRows(a);
}

==>

Program(Func(Ident,Param(Ident,MatrixType(Matrix,Dim(Ident),Dim(Ident),Semiring)),VectorType(Vector,Dim(Ident),Semiring),Block(LBrace,Return(CallExpr(BuiltInFunc,Ident)),RBrace)))

# Reduce columns
func reduceC(a: Matrix<s, s, int>) -> Matrix<1, s, int> {
  return reduceCols(a);
}

==>

Program(Func(Ident,Param(Ident,MatrixType(Matrix,Dim(Ident),Dim(Ident),Semiring)),MatrixType(Matrix,Dim(DimOne),Dim(Ident),Semiring),Block(LBrace,Return(CallExpr(BuiltInFunc,Ident)),RBrace)))

# Reduce all
func reduceAll(a: Matrix<s, s, int>) -> int {
  return reduce(a);
}

==>

Program(Func(Ident,Param(Ident,MatrixType(Matrix,Dim(Ident),Dim(Ident),Semiring)),Semiring,Block(LBrace,Return(CallExpr(BuiltInFunc,Ident)),RBrace)))

# Cast
func castType(a: int) -> real {
  return cast<real>(a);
}

==>

Program(Func(Ident,Param(Ident,Semiring),Semiring,Block(LBrace,Return(CastExpr(Cast,Semiring,Ident)),RBrace)))

# Zero
func zeroVal() -> int {
  return zero(int);
}

==>

Program(Func(Ident,Semiring,Block(LBrace,Return(ZeroExpr(Semiring)),RBrace)))

# One
func oneVal() -> int {
  return one(int);
}

==>

Program(Func(Ident,Semiring,Block(LBrace,Return(OneExpr(Semiring)),RBrace)))

# Pick any
func pickAnyVal(a: Matrix<s, s, int>) -> int {
  return pickAny(a);
}

==>

Program(Func(Ident,Param(Ident,MatrixType(Matrix,Dim(Ident),Dim(Ident),Semiring)),Semiring,Block(LBrace,Return(CallExpr(BuiltInFunc,Ident)),RBrace)))