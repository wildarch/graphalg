// RUN: split-file %s %t
// RUN: graphalg-translate --import-graphalg %t/input.gr > %t/parsed.mlir
// RUN: graphalg-opt --graphalg-to-core-pipeline --graphalg-set-dimensions='func=CDLP args=8x8' %t/parsed.mlir > %t/exec.mlir
// RUN: graphalg-exec %t/exec.mlir CDLP %t/graph.m | diff - %t/output.m

//--- graph.m
0 1
0 2
0 6
1 0
1 2
2 0
2 1
3 4
3 5
4 3
4 5
4 6
5 4
5 6
6 4
6 5
6 7
7 5

//--- input.gr
func isMax(v: int, max: trop_max_int) -> bool {
  return (cast<trop_max_int>(v) == max)
      * (v != zero(int));
}

func CDLP(graph: Matrix<s, s, bool>) -> Matrix<s, s, bool> {
    iterations = int(5);
    id = Vector<bool>(graph.nrows);
    id[:] = bool(true);
    L = diag(id);

    for i in int(0):iterations {
        step_forward = cast<int>(graph) * cast<int>(L);
        step_backward = cast<int>(graph.T) * cast<int>(L);
        step = step_forward (.+) step_backward;

        // Max per row
        max = reduceRows(cast<trop_max_int>(step));

        // Broadcast to all columns
        b = Vector<trop_max_int>(graph.ncols);
        b[:] = one(trop_max_int);
        max_broadcast = max * b.T;

        // Matrix with true at every position where L has max element.
        step_max = step (.isMax) max_broadcast;

        // Keep only one assigned label per vertex.
        // The implementation always picks the one with the lowest id.
        L = pickAny(step_max);
    }

    // Map isolated nodes to their own label.
    connected = reduceRows(graph) (.+) reduceRows(graph.T);
    isolated = Vector<bool>(graph.nrows);
    isolated<!connected>[:] = bool(true);
    L = diag(isolated) (.+) L;

    return L;
}

//--- output.m
0 0 true
1 0 true
2 0 true
3 4 true
4 3 true
5 3 true
6 3 true
7 3 true
