// RUN: graphalg-translate --import-graphalg < %s | FileCheck %s

// CHECK-LABEL: @AddMul
func AddMul(a:int, b:int, c:int) -> int {
    // CHECK: %[[#MUL:]] = graphalg.mxm %arg1, %arg2
    // CHECK: %[[#ADD:]] = graphalg.ewise %arg0 ADD %[[#MUL]]
    // CHECK: return %[[#ADD]]
    return a + b * c;
}

// CHECK-LABEL: @MulAdd
func MulAdd(a:int, b:int, c:int) -> int {
    // CHECK: %[[#MUL:]] = graphalg.mxm %arg0, %arg1
    // CHECK: %[[#ADD:]] = graphalg.ewise %[[#MUL]] ADD %arg2
    // CHECK: return %[[#ADD]]
    return a * b + c;
}

// CHECK-LABEL: @AddParensMul
func AddParensMul(a:int, b:int, c:int) -> int {
    // CHECK: %[[#ADD:]] = graphalg.ewise %arg0 ADD %arg1
    // CHECK: %[[#MUL:]] = graphalg.mxm %[[#ADD]], %arg2
    // CHECK: return %[[#MUL]]
    return (a + b) * c;
}

// CHECK-LABEL: @MulDot
func MulDot(a:int, m:Vector<s, int>) -> int {
    // CHECK: %[[#DIM:]] = graphalg.cast_dim #dim
    // CHECK: %[[#MUL:]] = graphalg.mxm %arg0, %[[#DIM]]
    // CHECK: return %[[#MUL]]
    return a * m.nrows;
}

// CHECK-LABEL: @EqAdd
func EqAdd(a:int, b:int, c:int) -> bool {
    // CHECK: %[[#ADD:]] = graphalg.ewise %arg1 ADD %arg2
    // CHECK: %[[#EQ:]] = graphalg.ewise %arg0 EQ %[[#ADD]]
    // CHECK: return %[[#EQ]]
    return a == b + c;
}

func NotEq(a:bool, b:bool) -> bool {
    // CHECK: %[[#NOT:]] = graphalg.not %arg0
    // CHECK: %[[#EQ:]] = graphalg.ewise %[[#NOT]] EQ %arg1
    // CHECK: return %[[#EQ]]
    return !a == b;
}

// TODO: ewise
