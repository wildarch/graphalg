#dim = #graphalg.dim<distinct[0]<>>
module @"<stdin>" {
  func.func @WCC(%arg0: !graphalg.mat<#dim x #dim x i1>) -> !graphalg.mat<#dim x #dim x i1> {
    %0 = graphalg.cast_dim #dim
    %1 = graphalg.const_mat false -> <#dim x 1 x i1>
    %2 = graphalg.literal true
    %3 = graphalg.broadcast %2 : <1 x 1 x i1> -> <#dim x 1 x i1>
    %4 = graphalg.diag %3 : !graphalg.mat<#dim x 1 x i1>
    %5 = graphalg.cast_dim #dim
    %6 = graphalg.for_dim range(#dim) init(%4) : !graphalg.mat<#dim x #dim x i1> -> !graphalg.mat<#dim x #dim x i1> body {
    ^bb0(%arg1: !graphalg.mat<1 x 1 x i64>, %arg2: !graphalg.mat<#dim x #dim x i1>):
      %7 = graphalg.mxm %arg0, %arg2 : <#dim x #dim x i1>, <#dim x #dim x i1>
      %8 = graphalg.ewise %arg2 ADD %7 : <#dim x #dim x i1>
      %9 = graphalg.transpose %arg0 : <#dim x #dim x i1>
      %10 = graphalg.mxm %9, %arg2 : <#dim x #dim x i1>, <#dim x #dim x i1>
      %11 = graphalg.ewise %8 ADD %10 : <#dim x #dim x i1>
      %12 = graphalg.pick_any %11 : <#dim x #dim x i1>
      graphalg.yield %12 : !graphalg.mat<#dim x #dim x i1>
    } until {
    }
    return %6 : !graphalg.mat<#dim x #dim x i1>
  }
}
